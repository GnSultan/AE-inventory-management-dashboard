// src/lib/supabase.ts
import { createClientComponentClient } from '@supabase/auth-helpers-nextjs'
import type { Database } from './types'

// Client-side Supabase client
export const createClient = () => createClientComponentClient<Database>()

// Utility functions for common database operations
export const supabaseQueries = {
  // Inventory queries
  async getActiveInventory() {
    const supabase = createClient()
    const { data, error } = await supabase
      .from('active_inventory')
      .select('*')
      .order('date_added', { ascending: false })
    
    if (error) throw error
    return data
  },

  async getLowStockAlerts() {
    const supabase = createClient()
    const { data, error } = await supabase
      .from('low_stock_alerts')
      .select('*')
      .order('stock_count', { ascending: true })
    
    if (error) throw error
    return data
  },

  // Device operations
  async getDevices(status?: 'available' | 'loaned' | 'sold' | 'trade_in') {
    const supabase = createClient()
    let query = supabase
      .from('devices')
      .select(`
        *,
        supplier:suppliers(name)
      `)
    
    if (status) {
      query = query.eq('status', status)
    }
    
    const { data, error } = await query.order('created_at', { ascending: false })
    if (error) throw error
    return data
  },

  async addDevice(device: {
    imei_serial: string
    brand: string
    model: string
    capacity?: string
    color?: string
    warranty_plan: '6_months' | '1_year' | '2_years'
    source?: string
    supplier_id?: string
    purchase_price?: number
  }) {
    const supabase = createClient()
    const { data, error } = await supabase
      .from('devices')
      .insert([device])
      .select()
      .single()
    
    if (error) throw error
    return data
  },

  async updateDeviceStatus(id: string, status: 'available' | 'loaned' | 'sold' | 'trade_in') {
    const supabase = createClient()
    const updateData: any = { status }
    
    if (status === 'sold') {
      updateData.date_sold = new Date().toISOString()
    } else if (status === 'loaned') {
      updateData.date_loaned = new Date().toISOString()
    }
    
    const { data, error } = await supabase
      .from('devices')
      .update(updateData)
      .eq('id', id)
      .select()
      .single()
    
    if (error) throw error
    return data
  },

  // Gadget operations
  async getGadgets() {
    const supabase = createClient()
    const { data, error } = await supabase
      .from('gadgets')
      .select(`
        *,
        supplier:suppliers(name)
      `)
      .order('created_at', { ascending: false })
    
    if (error) throw error
    return data
  },

  async addGadget(gadget: {
    brand: string
    model: string
    quantity: number
    supplier_id?: string
    purchase_price?: number
  }) {
    const supabase = createClient()
    const { data, error } = await supabase
      .from('gadgets')
      .insert([gadget])
      .select()
      .single()
    
    if (error) throw error
    return data
  },

  async updateGadgetQuantity(id: string, quantity: number) {
    const supabase = createClient()
    const { data, error } = await supabase
      .from('gadgets')
      .update({ quantity })
      .eq('id', id)
      .select()
      .single()
    
    if (error) throw error
    return data
  },

  // Sales operations
  async createSale(sale: {
    customer_name: string
    sale_type: string
    sale_price: number
    sale_source: 'inventory' | 'loan' | 'trade_in'
    device_id?: string
    gadget_id?: string
    gadget_quantity?: number
    item_description: string
    loan_id?: string
  }) {
    const supabase = createClient()
    
    // Generate sale_id
    const { data: saleData, error: saleError } = await supabase
      .from('sales')
      .insert([{
        sale_id: '', // Will be auto-generated by trigger
        ...sale
      }])
      .select()
      .single()
    
    if (saleError) throw saleError
    
    // Update device/gadget inventory
    if (sale.device_id) {
      await this.updateDeviceStatus(sale.device_id, 'sold')
      
      // Auto-generate warranty for device sales (except from loans)
      if (sale.sale_source !== 'loan') {
        await this.createWarranty(saleData.id, sale.device_id, sale.customer_name)
      }
    } else if (sale.gadget_id && sale.gadget_quantity) {
      // Decrease gadget quantity
      const { data: gadget } = await supabase
        .from('gadgets')
        .select('quantity')
        .eq('id', sale.gadget_id)
        .single()
      
      if (gadget) {
        await this.updateGadgetQuantity(sale.gadget_id, gadget.quantity - sale.gadget_quantity)
      }
    }
    
    return saleData
  },

  // Warranty operations
  async createWarranty(saleId: string, deviceId: string, customerName: string) {
    const supabase = createClient()
    
    // Get device details
    const { data: device, error: deviceError } = await supabase
      .from('devices')
      .select('brand, model, capacity, color, warranty_plan')
      .eq('id', deviceId)
      .single()
    
    if (deviceError || !device) {
      console.error('Error fetching device for warranty:', deviceError)
      return null
    }
    
    const deviceInfo = `${device.brand} ${device.model}${device.capacity ? ` ${device.capacity}` : ''}${device.color ? ` ${device.color}` : ''}`
    const warrantyStartDate = new Date()
    const warrantyEndDate = this.calculateWarrantyEndDate(warrantyStartDate, device.warranty_plan)
    
    const warrantyData = {
      warranty_id: '', // Will be auto-generated by trigger
      sale_id: saleId,
      device_id: deviceId,
      customer_name: customerName,
      device_info: deviceInfo,
      warranty_start_date: warrantyStartDate.toISOString().split('T')[0],
      warranty_end_date: warrantyEndDate.toISOString().split('T')[0],
      warranty_duration: device.warranty_plan,
      status: 'active'
    }
    
    const { data, error } = await supabase
      .from('warranties')
      .insert([warrantyData])
      .select()
      .single()
    
    if (error) {
      console.error('Error creating warranty:', error)
      return null
    }
    
    return data
  },

  calculateWarrantyEndDate(startDate: Date, plan: '6_months' | '1_year' | '2_years'): Date {
    const endDate = new Date(startDate)
    switch (plan) {
      case '6_months':
        endDate.setMonth(endDate.getMonth() + 6)
        break
      case '1_year':
        endDate.setFullYear(endDate.getFullYear() + 1)
        break
      case '2_years':
        endDate.setFullYear(endDate.getFullYear() + 2)
        break
    }
    return endDate
  },

  // Loan operations
  async createLoan(loan: {
    loaner_name: string
    loaner_contact?: string
    device_id?: string
    gadget_id?: string
    gadget_quantity?: number
    item_description: string
    expected_return_date?: string
    notes?: string
  }) {
    const supabase = createClient()
    
    const { data, error } = await supabase
      .from('loans')
      .insert([{
        loan_id: '', // Will be auto-generated by trigger
        ...loan
      }])
      .select()
      .single()
    
    if (error) throw error
    return data
  },

  async getLoans(status?: 'active' | 'returned' | 'sold') {
    const supabase = createClient()
    let query = supabase
      .from('loans')
      .select('*')
    
    if (status) {
      query = query.eq('status', status)
    }
    
    const { data, error } = await query.order('created_at', { ascending: false })
    if (error) throw error
    return data
  },

  async updateLoanStatus(id: string, status: 'returned' | 'sold') {
    const supabase = createClient()
    const { data, error } = await supabase
      .from('loans')
      .update({ 
        status,
        date_returned: new Date().toISOString()
      })
      .eq('id', id)
      .select()
      .single()
    
    if (error) throw error
    return data
  },

  // Warranty queries
  async getWarranties() {
    const supabase = createClient()
    const { data, error } = await supabase
      .from('warranties')
      .select(`
        *,
        sale:sales!inner(
          customer_name,
          sale_id,
          date_sold
        ),
        device:devices!inner(
          brand,
          model,
          capacity,
          color,
          imei_serial
        )
      `)
      .order('created_at', { ascending: false })
    
    if (error) throw error
    return data
  },

  // Get sales data for dashboard
  async getSalesData(days = 30) {
    const supabase = createClient()
    const startDate = new Date()
    startDate.setDate(startDate.getDate() - days)
    
    const { data, error } = await supabase
      .from('sales')
      .select('*')
      .gte('date_sold', startDate.toISOString())
      .order('date_sold', { ascending: false })
    
    if (error) throw error
    return data
  },

  // Supplier operations
  async getSuppliers() {
    const supabase = createClient()
    const { data, error } = await supabase
      .from('suppliers')
      .select('*')
      .order('name')
    
    if (error) throw error
    return data
  },

  async addSupplier(supplier: {
    name: string
    contact_info?: any
  }) {
    const supabase = createClient()
    const { data, error } = await supabase
      .from('suppliers')
      .insert([supplier])
      .select()
      .single()
    
    if (error) throw error
    return data
  }
}

// Real-time subscription helpers
export const subscribeToInventory = (callback: (payload: any) => void) => {
  const supabase = createClient()
  
  const subscription = supabase
    .channel('inventory_changes')
    .on('postgres_changes', 
      { event: '*', schema: 'public', table: 'devices' }, 
      callback
    )
    .on('postgres_changes', 
      { event: '*', schema: 'public', table: 'gadgets' }, 
      callback
    )
    .subscribe()
  
  return subscription
}

export const subscribeToSales = (callback: (payload: any) => void) => {
  const supabase = createClient()
  
  const subscription = supabase
    .channel('sales_changes')
    .on('postgres_changes', 
      { event: 'INSERT', schema: 'public', table: 'sales' }, 
      callback
    )
    .subscribe()
  
  return subscription
}